#!/usr/bin/perl  -w
#
# $Id$
#
# NAME: cloud_overlay:
#
# PURPOSE: To automatically produce a plot of wind vectors overlaid on
#          cloud imagery, either GOES or GMS 
#
# USAGE: 
#
#  cloud_overlay --region region_name --time time --windpath path_to_wind_files
# 
#  cloud_overlay --time time --satnum 10 --satname GOES --sensornum 4 \
#        --lon -180 --lon -110 --lat 10 --lat 50 --crdecimate 2 \
#          --crdecimate 4 --excluderows "38:42"
#
# For ease windpath may be abbreviated to 'path' or 'wpath'.
#
# MODIFIATION HISTORY
#
# $Log$
# Revision 1.14  2001/02/09 18:38:30  vapuser
# Added code for doing gridlines and rain flag.
# Put in more calls to VapErrorMsg
#
# Revision 1.13  2000/05/17 20:42:27  vapuser
# Reworked so that it wouldn't die from lack of cloud data.
#
# Revision 1.12  2000/05/15 23:21:52  vapuser
# Changed some '||'s to '&&' in calls to VapMailErrorMsg. Did some
# other stuff too, but I can't remember what.
#
# Revision 1.11  2000/02/11 16:47:10  vapuser
# Added calls to vap_perl::VarMailErrorMsg
#
#
# Revision 1.10  1999/09/22 20:25:36  vapuser
# Added 'length' and 'delta' processing
#
# Revision 1.9  1999/04/05 18:21:57  vapuser
# took out -d switch
#
# Revision 1.8  1999/04/02 22:29:56  vapuser
# Incorporated GMS5 overlays
#
# Revision 1.7  1998/11/20 19:50:44  vapuser
# updated to handle new 'multi-machine' processing scenario
#
# Revision 1.6  1998/11/04 19:37:58  vapuser
# Added a 'die'
#
# Revision 1.5  1998/10/22 21:37:52  vapuser
# Took out '-d' switch
#
# Revision 1.4  1998/10/17 00:15:52  vapuser
# Added code for CRDecimate,ExcludeCols and Decimate.
#
# Revision 1.3  1998/10/16 21:32:02  vapuser
# removed rcsid and some single quotes.
# changed 'require' to 'use'
#
# Revision 1.2  1998/10/02 20:10:15  vapuser
# added '$' in Id
#
# Revision 1.1  1998/10/02 20:09:40  vapuser
# Initial revision
#
#
#
use strict;
use lib $ENV{VAP_SFTWR_PERL};
use vap_perl;
use Gms5;
use Getopt::Long;
use File::Copy ;

my $usage =  "\nUsage:\n";
$usage .= " cloud_overlay --region REGION_DESIGNATION\n";
$usage .= "  --time TIME_DESIGNATION (GMT: yyyymmddThh:mm)\n";
$usage .= "  --windpath PATH_TO_WIND_FILES\n";
$usage .= "  --satname SATELLITE_NAME (.e.g. 'goes')\n";
$usage .= "  --satnum  SATELLITE_NUMBER (e.g. 10 for goes10)\n";
$usage .= "  --sensornum SENSOR_NUMBER (e.g. 1=vis, 2=ir2, 3=ir3, 4=ir4)\n";
$usage .= "  --lon lonmin ( --lon lonmax )\n";
$usage .= "  --lat latmin ( --lat latmax )\n";
$usage .= "  --crdecimate Col --crdecimate Row\n";
$usage .= "  --excludecol idl-array-submatrix-desg (as string)\n";
$usage .= "  --tellme: Calculates, reports variable values and exits\n\n";
$usage .= "  where: \n";

$usage .= "    REGION_DESIGNATION is the designation for the \n";

$usage .= "      region as it appears in the _overlay_defs_ file\n";
$usage .= "      See file $VAP_LIB/overlay_defs for the complete list of \n";
$usage .= "      predefined regions. If absent, the program falls over to using the \n";
$usage .= "      information given (or defaulted to) in the combination of the \n";
$usage .= "      satname/satnum/sensornum/lon/lat options. If there are no arguments,\n";
$usage .= "      this message is displayed\n";

$usage .= "    TIME_DESIGNATION: the GMT time of the area file to be gridded and \n";
$usage .= "      overlaid. The software will find the one closest to this time \n";
$usage .= "      so long as it isnt more than 2 hours distant. (format: yyyymmddThh:mm)\n";
$usage .= "      The default used depends on the satellite and the region\n";
$usage .= "      If absent, the software will determine time of the file it needs to find\n";
$usage .= "      based on the variables AscTime/DescTime, which are defined in the\n";
$usage .= "      data structure accessed via the 'REGION_DESIGNATION' or are defaulted\n";
$usage .= "      on the basis of the satname/satnum/sensornum variables\n";
$usage .= "      If there is no 'T' in the designation, the string is assumed to be \n";
$usage .= "      of the form hh:mm \n";
$usage .= "      (see --tellme option for a way of finding out what those defaults are\n";

$usage .= "    PATH_TO_WIND_FILES: pretty self explanatory.\n";
$usage .= "      Default given by environmental variable 'VAP_WINDS'\n";

$usage .= "    SATNAME: Name of satellite, Currently only 'goes' works\n";
$usage .= "      Maybe someday we'll be able to use gms (def='GOES')\n";

$usage .= "    SATNUM: Satellite Number (Currently only 10 and 8 work, since \n";
$usage .= "      we can only do 'GOES' satellites (def=10)\n";

$usage .= "    SENSORNUM: 1=vis, 2=ir2, 3=ir3, 4=ir4 (def=4)\n";

$usage .= "    LONMIN/LONMAX: The first instance of this option specifies the minimum\n";
$usage .= "      longitude (the lower right corner of the picture)\n";
$usage .= "      The second instance specifies the maximum longitude\n";
$usage .= "      Defaults are dependent on the satellite\n";

$usage .= "    LATMIN/LATMAX: See lonmin/lonmax\n";
$usage .= "    CRDECIMATE: The first instance designates the decimation in the 'column'\n";
$usage .= "      direction, the second the decimation in the 'row' direction\n";
$usage .= "      Default=[2,2]\n";
$usage .= "    LENGTH: Length fo the Vectors overplotting the cloud data\n";
$usage .= "    TELLME: Calculates, reports the values for all the variables and exits\n\n";
$usage .= "      Use this option to find out what the defaults are in any given situation\n";

$usage .= "    If one wishes to grid and overlay an arbitrary region not predefined\n";
$usage .= "    in the overlay_defs file, one may use the combination of \n";
$usage .= "    satname/satnum/sensornum/on/lat to do so. Each will take defaults if\n";
$usage .= "    not present, e.g. satname defaults to 'goes', satnum to '10', \n";
$usage .= "    sensornum to '4' and lon/lat limits take default appropriate to \n";
$usage .= "    whatever satname is. \n\n";



print "=====================================================\n";
print " $0: Beginning run\n";
print scalar(localtime());
print "\n===================================================\n";
die $usage if !@ARGV;
print "Input Arguments are:\n\t".join("\n\t",@ARGV)."\n";
$result=&GetOptions( 'region=s',\$region,
		    'time=s',  \$area_file_time,
		    'windpath|path|wpath=s', \$winds_path,
		    'satname=s',\$satname,
		    'satnum=i',\$satnum,
		    'sensornum=i',\$sensornum,
		    'lon=f@',\@lonlim,
		    'lat=f@',\@latlim,
		    'length=i',\$length,
		    'help', \$help,
		    'tellme', \$tellme );

if (!$result){
  vap_perl::VapMailErrorMsg(
       "cloud_overlay: Error parsing options\n" ,
	  "PARSEOPTIONSERROR" ); 
    die "Error parsing options\n"; 
} 
die $usage if $help;

# Set the IDL starup file to get '24 bit true' color
#$ENV{'IDL_STARTUP'}="/disk4/vapuser/idl-startup-true24";

my ($asctime, $desctime,$nvectors, $crdecimate,
    $delta, $rainflag, $rf_action, $rf_color, $excludecols,
    $time, $lastrec, $fullregionname, $regionname, $msg);


if ($region) {
  # Get the defaults for overlays.
  do { 
    $msg="cloud_overlay: Region $region doesn't exist in OVERLAY DEFAULTS Table!\n";
    $msg.="Execute 'cloud_overlay_regions' to find valid regions\n";
  vap_perl::VapMailErrorMsg( $msg,
		"UNKNOWN REGION") && 
		  die "Region $region doesn't exist in OVERLAY DEFAULTS Table!\n"} 
  if !defined($vap_perl::overlay_defs{ $region }{ Region } );

  $satname     = $vap_perl::overlay_defs{ $region } { CloudData }{ Satellite   };   
  $lonlim      = $vap_perl::overlay_defs{ $region } { CloudData }{ LonLim      };     
  $latlim      = $vap_perl::overlay_defs{ $region } { CloudData }{ LatLim      };     
  $satnum      = $vap_perl::overlay_defs{ $region } { CloudData }{ SatNum      };     
  $sensornum   = $vap_perl::overlay_defs{ $region } { CloudData }{ SensorNum   };
  $asctime     = $vap_perl::overlay_defs{ $region } { CloudData }{ AscTime     };
  $desctime    = $vap_perl::overlay_defs{ $region } { CloudData }{ DescTime    };
  $nvectors    = $vap_perl::overlay_defs{ $region } { WVCData   }{ NVectors    }; 
  $crdecimate  = $vap_perl::overlay_defs{ $region } { WVCData   }{ CRDecimate  };
  $length      = $vap_perl::overlay_defs{ $region } { WVCData   }{ Length      };
  $delta       = $vap_perl::overlay_defs{ $region } { WVCData   }{ Delta       };
  $rainflag    = $vap_perl::overlay_defs{ $region } { WVCData   }{ rainflag    };
  $rf_action   = $vap_perl::overlay_defs{ $region } { WVCData   }{ rf_action   };
  $rf_color    = $vap_perl::overlay_defs{ $region } { WVCData   }{ rf_color    };
  $excludecols = $vap_perl::overlay_defs{ $region } { WVCData   }{ ExcludeCols };
  
  @lonlim=@{$lonlim};
  @latlim=@{$latlim};
  
  if (!$area_file_time) {
    $asctime  = vap_perl::prepend_yyyymmdd($asctime);
    $desctime = vap_perl::prepend_yyyymmdd($desctime);
    my ($sec,$min,$hour,$mday,$mon,$year)=gmtime($^T-4*3600);
    $time=sprintf("%04d%02d%02dT%02d:%02d",
		  $year+1900,$mon+1,$mday,$hour,$min);
    my @testtimes=( $time, $asctime,$desctime);
    @testtimes = sort @testtimes;
    foreach (@testtimes) {
      last if /$time/;
      $lastrec=$_;
    }
    
    if (!$lastrec)  { 
      # current time (less 1 hour) is earlier than either 
      # asctime or desctime. Take testtimes[2] 
      # (they're sorted, after all ) and subtract 1 day from it.
      $testsecs = vap_perl::vaptime2systime($testtimes[2]);
      $time = vap_perl::systime2vaptime($testsecs-86400);
    } else {
      $time=$lastrec;
    }
  } else {
    $time=$area_file_time;
  }
} else {
  
  $satname = "GOES" if !$satname;
  $satnum = 10 if !$satnum;
  $sensornum = 4 if !$satnum;
  
  if (!$asctime) {
    SWITCH: {
      $asctime="07:00" , last SWITCH if $satnum == 10;
      $asctime="03:00" , last SWITCH if $satnum == 8;
    }
  }
  
  if (!$desctime) {
    SWITCH: {
      $desctime="20:00" , last SWITCH if $satnum == 10;
      $desctime="16:00" , last SWITCH if $satnum == 8;
    }
  }
  
  if (!@lonlim){
    SWITCH: {
      @lonlim=(-175,-115), last SWITCH if $satnum==10;
      @lonlim=(-90,-48), last SWITCH if $satnum==8;
    }
  } elsif ($#lonlim==0) {
    SWITCH: {
      $lonlim[1]=-115, last SWITCH if $satnum==10;
      $lonlim[1]=-48, last SWITCH if $satnum==8;
    }
  }
  
  if (!@latlim){
    SWITCH: {
      @latlim=(25,65), last SWITCH if $satnum==10;
      @latlim=(25,52), last SWITCH if $satnum==8;
    }
  } elsif ($#latlim ==0) {
    SWITCH: {
      $latlim[1] = 65, last SWITCH if $satnum==10;
      $latlim[1] = 52, last SWITCH if $satnum==8;
    }
  }
  
  @crdecimate=(2,2) unless @crdecimate;
  $excludecols="" unless @excludecols;
  
  # Construct the time to be used in finding the correct 
  # goes/gms/whatever file.
  $asctime  = vap_perl::prepend_yyyymmdd($asctime);
  $desctime = vap_perl::prepend_yyyymmdd($desctime);
  my ($sec,$min,$hour,$mday,$mon,$year)=vap_perl::systime2vaptime($^T-3600);
  $time=sprintf("%04d%02d%02dT%02d:%02d",
		$year+1900,$mon,$mday,$hour,$min);
  my @testtimes=( $time, $asctime,$desctime);
  @testtimes = sort @testtimes;
  foreach (@testtimes) {
    last if /$time/;
    $lastrec=$_;
  }
  
  if (!$lastrec)  { 
    # current time (less 1 hour) is earlier than either 
    # asctime or desctime. Take testtimes[2] 
    # (they're sorted, after all ) and subtract 1 day from it.
    $testsecs = vap_perl::vaptime2systime($testtimes[2]);
    $time = vap_perl::systime2vaptime($testsecs);
  } else {
    $time=$lastrec;
  }
  
  
}

$satname =~ tr/a-z/A-Z/;
$fullregionname=join("",split( /_/, $region)) || "NOREGION";
$regionname=join( "", (split( /_/, $region))[3,4] ) || "NR";

print "\nArguments and variables are...\n";
print "\nsatname     = $satname\n";        
print "satnum      = $satnum\n" ;
print "sensornum   = $sensornum\n";      
print "lon         = @lonlim\n";         
print "lat         = @latlim\n" ;        
print "asctime     = $asctime\n";       
print "desctime    = $desctime\n";      
print "time        = $time\n" if $time; 
print "crdecimate  = @$crdecimate\n";  
print "length      = $length\n";  
print "delta       = $delta\n" if $delta; 
print "rainflag    = $rainflag\n";
print "rf_action   = $rf_action\n";
print "rf_color    = $rf_color\n";
print "excludecols = $excludecols\n\n";
print "Taking type = $type\n" if $type;  
print "Output overlay file will have region name $regionname\n";
print "Output HTTP file will have region name $fullregionname\n";

exit if ($tellme);

# Sanity check the arguments: 
@lonlim=vap_perl::fixlonrange( @lonlim );
do {
  vap_perl::VapMailErrorMsg( "cloud_overlay: $satname not in allowed list\n", 
			       "UNKNOWN SATNAME");
  die "$satname not in allowed list\n"; } unless $satname =~ /(GOES|GMS)/;
do {vap_perl::VapMailErrorMsg( "cloud_overaly: $satnum not in allowed list (8,10)\n", 
			"UNKNOWN SATNUM") &&
     die "$satnum not in allowed list (8,10)\n" } unless $satnum =~ /(5|8|10)/;
do {vap_perl::VapMailErrorMsg( "cloud_overaly: $sensornum not in allowed range (1-4)\n", 
			"UNKNOWN SENSORNUM") &&
     die "$sensornum not in allowed range (1-4)\n"}  unless $sensornum =~ /(1|2|3|4)/;
if (abs($lonlim[0]) > 360 || abs($lonlim[1]) > 360){ 
  vap_perl::VapMailErrorMsg("cloud_overlay: Out of range Long Lims\n  (@lonlim)\n", 
			     "LONGLIMS OUTOFRANGE");
  die "Out of range Long Lims\n  (@lonlim)\n";
}

if (abs($latlim[0]) > 90 || abs($latlim[1]) > 90) {
  vap_perl::VapMailErrorMsg("cloud_overlay: Out of range Lat Lims\n  (@latlim)\n", 
			     "LATLIMS OUTOFRANGE");
  die "Out of range Lat Lims\n  (@latlim)\n";
}




  #========================================
  #
  # Start the real processing
  #
  # ========================================


  # create lock file (for IDL session)

my $user=$ENV{'USER'};

$overlay_dir= $overlay_dir || $ENV{VAP_OPS_OVERLAY};
do {
 vap_perl::VapMailErrorMsg( "cloud_overlay: Undefined env vars(VAP_OPS_OVERLAY)\n", 
			    "UNDEFINED_ENV_VARS!");
     die "ENV variable VAP_OPS_OVERLAY is undefined!\n";
 } unless $overlay_dir;



$tmpdir = $tmpdir || $ENV{VAP_OPS_TMPFILES};
do {
 vap_perl::VapMailErrorMsg("$0: Undefined env vars (VAP_OPS_TMPDIR)\n",
			   "UNDEFINED_ENV_VARS!");
   die "ENV variable VAP_OPS_TMPFILES is undefined!\n";
 } unless $tmpdir;



my $lock_file="$tmpdir/$user.cloud_overlay.$$.lock";

do { 
  vap_perl::VapMailErrorMsg("cloud_overlay: Couldn't open $lock_file\n", 
			       "OPENERR <LOCKFILE>");
    die "Couldn't open $lock_file\n"} unless open (LOCK,">$lock_file");
print LOCK "$$\n";
close (LOCK);

my ($minlon, $maxlon, $minlat, $maxlat, $mapLimits, $gridded_file, $wwwfile);

$minlon=$lonlim[0];
$maxlon=$lonlim[1];
$minlat=$latlim[0];
$maxlat=$latlim[1];
$mapLimits ="[ $minlon, $minlat, $maxlon, $maxlat ]";


my @gms5sensornames=('ir1','ir2','ir3','vis');

if ($satname =~ /GMS/) {

  if (!Gms5::GetAllFileLists())
  {
    vap_perl::VapMailErrorMsg(
			      "cloud_overlay:Can't Get all Gms5 archives listings!\n",
			      "GMS5 GETALLFILELISTS");
      die "Can't Get all Gms5 archives listings!\n" ;
    }
  
  my @isec=Gms5::GetIntersection($gms5sensornames[$sensornum-1]);
  if (!$isec[0]) { 
    vap_perl::VapMailErrorMsg("cloud_overlay: Can't get GMS5 intersect\n", 
			      "GMS5 INTERSECT");
      die "Can't get GMS5 intersection\n";
  } 
  my $mindiff=1.e10;
  $gridded_file="";
  my $testsecs=vap_perl::vaptime2systime($time);
  foreach my $datetime (@isec) {
    my $syst=Gms5::Gms5DateTime2SysTime($datetime);
    my $dif = abs($syst-$testsecs) ;
    if ( $dif <= $mindiff ) {
      $gridded_file=$datetime ;
      $mindiff = $dif;
    }
  }
  if ($mindiff > 7200){ 
    $gridded_file="";

      # Don't fail if there isn't a file close enough!
      # But don't bother to FTP all the requisite files either!
      # Still send the error message, though!

    vap_perl::VapMailErrorMsg(
			      "cloud_overlay: No Files closer than 2 hours! <$mindiff>\n",
 			      "GMS5 MINDIFF");
  }  else {
    
    my $T=time();
    if (!Gms5::GetAll($gridded_file)){
      vap_perl::VapMailErrorMsg(
				"cloud_overlay: Can't GetAll for datetime $gridded_file\n", 
				"GMS5 GRIDDEDFILE");
	die "Can't GetAll for datetime $gridded_file\n";
    }
    $T=time()-$T;
    print "GMS5::GetAll took $T seconds \n";
  }

} else {
  # It's a GOES file 
  # Supposedly we can now get and grid the AREA file 


  # Supposedly we can now get and grid the AREA file 
  my $T=time();
  print "$0: Calling GAG with arguments\n\tsatnum:$satnum\n\tsensornum:$sensornum";
  print "\n\ttime:$time\n\tminlon:$minlon\n\tminlat:$minlat\n\tmaxlon:$maxlon\n\tmaxlat:$maxlat\n";
  $gridded_file = vap_perl::gag( $satnum, $sensornum, $time, 
				 $minlon, $minlat, $maxlon, $maxlat );
  $T=time()-$T;
  print "GAG took $T seconds\n";



  # New mode. Don't fail if the gridding didn't work. Just continue
    # and let it plot the vectors anyway.
  
}



# The IDL routines like time as yyyy/mm/dd/hh/mm. 
# So, construct this time string.

my ($idl_time_string, $idl_tmp_file, $exe_str);
$idl_time_string=vap_perl::vaptime2idltime($time);
$idl_tmp_file="$tmpdir/$0_idl_called_by_perl_$$.pro";
print "Writing IDL tmp file $idl_tmp_file\n";

open(IDLFILE,">$idl_tmp_file") || 
    do {vap_perl::VapMailErrorMsg(
				  "Cloud_overlay: Couldn't open $idl_tmp_file\n",
				  "BAD IDL TMPFILE OPEN") && 
				  die "Couldn't open $idl_tmp_file\n"};


$exe_str = "cloud_overlay,\'$gridded_file\',\'$idl_time_string\'";
$exe_str .= ",$delta,wpath = \'$vap_perl::VAP_WINDS\'";
$exe_str .= ",lockfile=\'$lock_file\',length=$length";
$exe_str .= ",CRDecimate=[".join(",",@$crdecimate)."]";
$exe_str .= ",ExcludeCols=\'$excludecols\'";
$exe_str .= ",rainflag=$rainflag,rf_action=$rf_action,rf_color=$rf_color";
$exe_str .= ",mapLimits=$mapLimits";
$exe_str .= ",/gridlines";
$exe_str .= ",gmsType=\'$gms5sensornames[$sensornum-1]\'" if ($satname =~ /GMS/);
  
print IDLFILE "$exe_str\nexit\n" || 
   {vap_perl::VapMailErrorMsg(
       "cloud_overlay: Can't write to idl tmp file $idl_tmp_file\n",
       "BAD WRITE TO IDL TMPFILE") && 
	   die "Can't write to idl tmp file $idl_tmp_file\n"};
close IDLFILE;

print "wrote following to idl_tmp_file\n  $exe_str\n";

$exe_str=$vap_perl::IDLEXE." ".$idl_tmp_file;
my $r=system( $exe_str )/256;

if ($r != 0){
  vap_perl::VapMailErrorMsg("cloud_overlay: Error in IDL\n",
			    "ERROR CALLING IDL");
    die " Error in IDL\n";
}


do{
  vap_perl::VapMailErrorMsg(
			    "cloud_overlay: Couldn't open $lock_file after IDL \n",
			    "ERROR OPEN LOCKFILE");
    die "Couldn't open $lock_file after IDL \n";} unless open ( LOCK, "<$lock_file");
my @idlout = <LOCK>;
close (LOCK);


  # see if there are any lines in the idl output file 
  # with the work ERROR in them. Exit if there are.

foreach (@idlout) {
  if (/ERROR/) {
    print "Error in IDL processing \n";
    print @idlout;
    $msg=join "\n",@idlout;
    vap_perl::VapMailErrorMsg($msg,"ERRORINIDLPROC");
    exit;
  }
}

unlink $lock_file  ||  print "Couldn't delete $lock_file \n";

  # goes_overlay gives the output gif file a name based on the input
  # grid file name. Get that name and rename the file to the standard
  # 'pac_overlay_$type.gif'

my $output_file_name_file="$overlay_dir/auto_cloud_overlay_output_file.$$";


do {vap_perl::VapMailErrorMsg(
			      "cloud_overlay: Couldn't CD to $overlay_dir\n",
			      "CD TO OVERLAY_DIR ERROR");
  die " Couldn't CD to $overlay_dir\n\n";} unless chdir $overlay_dir;


do {
  vap_perl::VapMailErrorMsg(
			    "cloud_overlay: Can't open $output_file_name_file\n",
			    "AUTO CLOUD OVERLAY OUTPUT FILE OPEN ERROR");
    die "Can't open $output_file_name_file\n";
  } unless open (PICTURENAME,"<$output_file_name_file");

my @picturefile=<PICTURENAME>;
close(PICTURENAME);
  unlink "$output_file_name_file" || 
      print "Couldn't delete $output_file_name_file\n";

  # Read the picture name
my $picture = "$picturefile[0]";
chomp $picture;
my @tmp = split("/",$picture);
$picture = $tmp[$#tmp];
@tmp = split( /\./, $picture );
my $fileroot = $tmp[0];

  # Read the thumbnail name
my $thumbnail = $picturefile[1];
chomp$thumbnail;
@tmp = split("/",$thumbnail);
$thumbnail = $tmp[$#tmp];
@tmp = split( /\./, $thumbnail );
my $thumbnailroot = $tmp[0];

   #
   #---------------------- the file ------------------------
   #

my $VAP_OVERLAY_ARCHIVE = $ENV{VAP_OVERLAY_ARCHIVE} ||
do {
  vap_perl::VapMailErrorMessage("Undefined ENV var (VAP_OVERLAY_ARCHIVE)\n",
				"UNDEFINED_ENV_VAR");
    die "Undefined ENV var (VAP_OVERLAY_ARCHIVE)\n";
  } unless $VAP_OVERLAY_ARCHIVE;

my $file="$VAP_OVERLAY_ARCHIVE/$fileroot-$regionname.jpeg";
print "Renaming $picture to $file\n";
do {vap_perl::VapMailErrorMsg(
			      "cloud_overlay: Couldn't rename $picture to $file, error = $!\n",
			      "PICTURE COPY ERROR");
	die "Couldn't rename $picture to $file, error = $!\n";} unless copy($picture,$file);
unlink $picture;
chmod 0755, $file || print  "Couldn't chmod $file to a+r\n";


  # create name of file in images archive to be linked to it.

my $VAP_WWW_TOP = $ENV{VAP_WWW_TOP};
do {
  vap_perl::VapMailErrorMessage("Undefined ENV var (VAP_WWW_TOP)\n",
				"UNDEFINED_ENV_VAR");
    die "Undefined ENV var (VAP_WWW_TOP)\n";
  } unless $VAP_WWW_TOP;

$wwwfile="$VAP_WWW_TOP/images/$fullregionname.jpeg";

  #delete it if it exists
if (-e $wwwfile) {
  unlink ($wwwfile ) || print "Couldn't unlink $wwwfile\n";
}



  # create the symbolic link to the gif file.
print "Linking $wwwfile to $file\n";
symlink( $file, $wwwfile ) || print "Couldn't link $wwwfile to $file \n";


   #
   #---------------------- And its thumbnail ------------------------
   #


  # copy thumbnail to image overlay archive.
$file= "$VAP_OVERLAY_ARCHIVE/$thumbnailroot-$regionname.TN.jpeg";
print "Renaming $thumbnail to $file\n";
do {vap_perl::VapMailErrorMsg(
			      "cloud_overlay: Couldn't rename $thumbnail to $file, error = $!\n",
			      "THUMBNAIL COPY ERROR") ;
	die "Couldn't rename $thumbnail to $file, error = $!\n";} unless copy($thumbnail,$file);
unlink $thumbnail;
chmod 0755, $file || print  "Couldn't chmod $file to a+r\n";



  # Create the symbolic name for the thumbnail

$wwwfile="$VAP_WWW_TOP/images/$fullregionname.TN.jpeg";
  #delete it if it exists
if (-e $wwwfile) {
  unlink ($wwwfile ) || print "Couldn't unlink $wwwfile\n";
}

  # create the symbolic link to the gif file.
print "Linking $wwwfile to $file\n";
symlink( $file, $wwwfile ) || print "Couldn't link $wwwfile to $file \n";

  # go to where the index.html is

do {vap_perl::VapMailErrorMsg(
          "cloud_overlay: Couldn't go to $VAP_WWW_TOP\n",
			      "CD ERROR WWW TOP DIR");
	die "Couldn't CD to $VAP_WWW_TOP\n";} unless chdir $VAP_WWW_TOP;

  # update the dates in that file
print "Updating index.html\n";
vap_perl::date_index();

  # make sure it's readible.
do {vap_perl::VapMailErrorMsg("cloud_overlay: Couldn't chmod index.html to 0644\n",
			      "INDEX.HTML CHMOD ERROR");
  die "Couldn't chmod index.html to 0644\n"} unless chmod(0644,"index.html");
my $tottime=time()-$^T;

print "$0: Total Time: $tottime\n";
print "=================================================\n" ;
print "$0:\n Ending run\n";
print scalar(localtime());
print "\n================================================\n";

exit;

