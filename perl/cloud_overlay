#!/usr/bin/perl 
#
# $Id$
#
# NAME: cloud_overlay:
#
# PURPOSE: To automatically produce a plot of wind vectors overlaid on
#          cloud imagery, either GOES or GMS 
#
# USAGE: 
#
#  cloud_overlay --region region_name --time time --windpath path_to_wind_files
# 
#  cloud_overlay --time time --satnum 10 --satname GOES --sensornum 4 \
#        --lon -180 --lon -110 --lat 10 --lat 50 --crdecimate 2 \
#          --crdecimate 4 --excluderows "38:42"
#
# For ease windpath may be abbreviated to 'path' or 'wpath'.
#
# MODIFIATION HISTORY
#
# $Log$
# Revision 1.13  2000/05/17 20:42:27  vapuser
# Reworked so that it wouldn't die from lack of cloud data.
#
# Revision 1.12  2000/05/15 23:21:52  vapuser
# Changed some '||'s to '&&' in calls to VapMailErrorMsg. Did some
# other stuff too, but I can't remember what.
#
# Revision 1.11  2000/02/11 16:47:10  vapuser
# Added calls to vap_perl::VarMailErrorMsg
#
#
# Revision 1.10  1999/09/22 20:25:36  vapuser
# Added 'length' and 'delta' processing
#
# Revision 1.9  1999/04/05 18:21:57  vapuser
# took out -d switch
#
# Revision 1.8  1999/04/02 22:29:56  vapuser
# Incorporated GMS5 overlays
#
# Revision 1.7  1998/11/20 19:50:44  vapuser
# updated to handle new 'multi-machine' processing scenario
#
# Revision 1.6  1998/11/04 19:37:58  vapuser
# Added a 'die'
#
# Revision 1.5  1998/10/22 21:37:52  vapuser
# Took out '-d' switch
#
# Revision 1.4  1998/10/17 00:15:52  vapuser
# Added code for CRDecimate,ExcludeCols and Decimate.
#
# Revision 1.3  1998/10/16 21:32:02  vapuser
# removed rcsid and some single quotes.
# changed 'require' to 'use'
#
# Revision 1.2  1998/10/02 20:10:15  vapuser
# added '$' in Id
#
# Revision 1.1  1998/10/02 20:09:40  vapuser
# Initial revision
#
#
#


use vap_perl;
use Gms5;
use Getopt::Long;
use File::Copy ;

$usage =  "\nUsage:\n";
$usage .= " cloud_overlay --region REGION_DESIGNATION\n";
$usage .= "  --time TIME_DESIGNATION (GMT: yyyymmddThh:mm)\n";
$usage .= "  --windpath PATH_TO_WIND_FILES\n";
$usage .= "  --satname SATELLITE_NAME (.e.g. 'goes')\n";
$usage .= "  --satnum  SATELLITE_NUMBER (e.g. 10 for goes10)\n";
$usage .= "  --sensornum SENSOR_NUMBER (e.g. 1=vis, 2=ir2, 3=ir3, 4=ir4)\n";
$usage .= "  --lon lonmin ( --lon lonmax )\n";
$usage .= "  --lat latmin ( --lat latmax )\n";
$usage .= "  --crdecimate Col --crdecimate Row\n";
$usage .= "  --excludecol idl-array-submatrix-desg (as string)\n";
$usage .= "  --tellme: Calculates, reports variable values and exits\n\n";
$usage .= "  where: \n";

$usage .= "    REGION_DESIGNATION is the designation for the \n";

$usage .= "      region as it appears in the _overlay_defs_ file\n";
$usage .= "      See file $VAP_LIB/overlay_defs for the complete list of \n";
$usage .= "      predefined regions. If absent, the program falls over to using the \n";
$usage .= "      information given (or defaulted to) in the combination of the \n";
$usage .= "      satname/satnum/sensornum/lon/lat options. If there are no arguments,\n";
$usage .= "      this message is displayed\n";

$usage .= "    TIME_DESIGNATION: the GMT time of the area file to be gridded and \n";
$usage .= "      overlaid. The software will find the one closest to this time \n";
$usage .= "      so long as it isnt more than 2 hours distant. (format: yyyymmddThh:mm)\n";
$usage .= "      The default used depends on the satellite and the region\n";
$usage .= "      If absent, the software will determine time of the file it needs to find\n";
$usage .= "      based on the variables AscTime/DescTime, which are defined in the\n";
$usage .= "      data structure accessed via the 'REGION_DESIGNATION' or are defaulted\n";
$usage .= "      on the basis of the satname/satnum/sensornum variables\n";
$usage .= "      If there is no 'T' in the designation, the string is assumed to be \n";
$usage .= "      of the form hh:mm \n";
$usage .= "      (see --tellme option for a way of finding out what those defaults are\n";

$usage .= "    PATH_TO_WIND_FILES: pretty self explanatory.\n";
$usage .= "      Default given by environmental variable 'VAP_WINDS'\n";

$usage .= "    SATNAME: Name of satellite, Currently only 'goes' works\n";
$usage .= "      Maybe someday we'll be able to use gms (def='GOES')\n";

$usage .= "    SATNUM: Satellite Number (Currently only 10 and 8 work, since \n";
$usage .= "      we can only do 'GOES' satellites (def=10)\n";

$usage .= "    SENSORNUM: 1=vis, 2=ir2, 3=ir3, 4=ir4 (def=4)\n";

$usage .= "    LONMIN/LONMAX: The first instance of this option specifies the minimum\n";
$usage .= "      longitude (the lower right corner of the picture)\n";
$usage .= "      The second instance specifies the maximum longitude\n";
$usage .= "      Defaults are dependent on the satellite\n";

$usage .= "    LATMIN/LATMAX: See lonmin/lonmax\n";
$usage .= "    CRDECIMATE: The first instance designates the decimation in the 'column'\n";
$usage .= "      direction, the second the decimation in the 'row' direction\n";
$usage .= "      Default=[2,2]\n";
$usage .= "    LENGTH: Length fo the Vectors overplotting the cloud data\n";
$usage .= "    TELLME: Calculates, reports the values for all the variables and exits\n\n";
$usage .= "      Use this option to find out what the defaults are in any given situation\n";

$usage .= "    If one wishes to grid and overlay an arbitrary region not predefined\n";
$usage .= "    in the overlay_defs file, one may use the combination of \n";
$usage .= "    satname/satnum/sensornum/on/lat to do so. Each will take defaults if\n";
$usage .= "    not present, e.g. satname defaults to 'goes', satnum to '10', \n";
$usage .= "    sensornum to '4' and lon/lat limits take default appropriate to \n";
$usage .= "    whatever satname is. \n\n";



die $usage if !@ARGV;
$result=&GetOptions( 'region=s',\$region,
		    'time=s',  \$area_file_time,
		    'windpath|path|wpath=s', \$winds_path,
		    'satname=s',\$satname,
		    'satnum=i',\$satnum,
		    'sensornum=i',\$sensornum,
		    'lon=f@',\@lonlim,
		    'lat=f@',\@latlim,
		    'length=i',\$length,
		    'help', \$help,
		    'tellme', \$tellme );

if (!$result){
  vap_perl::VapMailErrorMsg(
       "cloud_overlay: Error parsing options\n" ,
	  "PARSEOPTIONSERROR" ); 
    die "Error parsing options\n"; 
} 
die $usage if $help;

# Set the IDL starup file to get '24 bit true' color
#$ENV{'IDL_STARTUP'}="/disk4/vapuser/idl-startup-true24";

if ($region) {
  # Get the defaults for overlays.
  do { 
    $msg="cloud_overlay: Region $region doesn't exist in OVERLAY DEFAULTS Table!\n";
    $msg.="Execute 'cloud_overlay_regions' to find valid regions\n";
  vap_perl::VapMailErrorMsg( $msg,
		"UNKNOWN REGION") && 
		  die "Region $region doesn't exist in OVERLAY DEFAULTS Table!\n"} 
  if !defined($vap_perl::overlay_defs{ $region }{ Region } );

  $satname     = $vap_perl::overlay_defs{ $region } { CloudData }{ Satellite   };   
  $lonlim      = $vap_perl::overlay_defs{ $region } { CloudData }{ LonLim      };     
  $latlim      = $vap_perl::overlay_defs{ $region } { CloudData }{ LatLim      };     
  $satnum      = $vap_perl::overlay_defs{ $region } { CloudData }{ SatNum      };     
  $sensornum   = $vap_perl::overlay_defs{ $region } { CloudData }{ SensorNum   };
  $asctime     = $vap_perl::overlay_defs{ $region } { CloudData }{ AscTime     };
  $desctime    = $vap_perl::overlay_defs{ $region } { CloudData }{ DescTime    };
  $nvectors    = $vap_perl::overlay_defs{ $region } { WVCData   }{ NVectors    }; 
  $crdecimate  = $vap_perl::overlay_defs{ $region } { WVCData   }{ CRDecimate  };
  $length      = $vap_perl::overlay_defs{ $region } { WVCData   }{ Length      };
  $delta       = $vap_perl::overlay_defs{ $region } { WVCData   }{ Delta       };
  $rainflag    = $vap_perl::overlay_defs{ $region } { WVCData   }{ rainflag    };
  $rf_action   = $vap_perl::overlay_defs{ $region } { WVCData   }{ rf_action   };
  $rf_color    = $vap_perl::overlay_defs{ $region } { WVCData   }{ rf_color    };
  $excludecols = $vap_perl::overlay_defs{ $region } { WVCData   }{ ExcludeCols };
  
  @lonlim=@$lonlim;
  @latlim=@$latlim;
  
  if (!$area_file_time) {
    $asctime  = vap_perl::prepend_yyyymmdd($asctime);
    $desctime = vap_perl::prepend_yyyymmdd($desctime);
    ($sec,$min,$hour,$mday,$mon,$year)=gmtime($^T-4*3600);
    $time=sprintf("%04d%02d%02dT%02d:%02d",
		  $year+1900,$mon+1,$mday,$hour,$min);
    @testtimes=( $time, $asctime,$desctime);
    @testtimes = sort @testtimes;
    foreach $rec (@testtimes) {
      last if $rec =~ /$time/;
      $lastrec=$rec;
    }
    
    if (!$lastrec)  { 
      # current time (less 1 hour) is earlier than either 
      # asctime or desctime. Take testtimes[2] 
      # (they're sorted, after all ) and subtract 1 day from it.
      $testsecs = vap_perl::vaptime2systime($testtimes[2]);
      $time = vap_perl::systime2vaptime($testsecs-86400);
    } else {
      $time=$lastrec;
    }
  } else {
    $time=$area_file_time;
  }
} else {
  
  $satname = "GOES" if !$satname;
  $satnum = 10 if !$satnum;
  $sensornum = 4 if !$satnum;
  
  if (!$asctime) {
    SWITCH: {
      $asctime="07:00" , last SWITCH if $satnum == 10;
      $asctime="03:00" , last SWITCH if $satnum == 8;
    }
  }
  
  if (!$desctime) {
    SWITCH: {
      $desctime="20:00" , last SWITCH if $satnum == 10;
      $desctime="16:00" , last SWITCH if $satnum == 8;
    }
  }
  
  if (!@lonlim){
    SWITCH: {
      @lonlim=(-175,-115), last SWITCH if $satnum==10;
      @lonlim=(-90,-48), last SWITCH if $satnum==8;
    }
  } elsif ($#lonlim==0) {
    SWITCH: {
      $lonlim[1]=-115, last SWITCH if $satnum==10;
      $lonlim[1]=-48, last SWITCH if $satnum==8;
    }
  }
  
  if (!@latlim){
    SWITCH: {
      @latlim=(25,65), last SWITCH if $satnum==10;
      @latlim=(25,52), last SWITCH if $satnum==8;
    }
  } elsif ($#latlim ==0) {
    SWITCH: {
      $latlim[1] = 65, last SWITCH if $satnum==10;
      $latlim[1] = 52, last SWITCH if $satnum==8;
    }
  }
  
  @crdecimate=(2,2) unless @crdecimate;
  $excludecols="" unless @excludecols;
  
  # Construct the time to be used in finding the correct 
  # goes/gms/whatever file.
  $asctime  = vap_perl::prepend_yyyymmdd($asctime);
  $desctime = vap_perl::prepend_yyyymmdd($desctime);
  ($sec,$min,$hour,$mday,$mon,$year)=vap_perl::systime2vaptime($^T-3600);
  $time=sprintf("%04d%02d%02dT%02d:%02d",
		$year+1900,$mon,$mday,$hour,$min);
  @testtimes=( $time, $asctime,$desctime);
  @testtimes = sort @testtimes;
  foreach $rec (@testtimes) {
    last if $rec =~ /$time/;
    $lastrec=$rec;
  }
  
  if (!$lastrec)  { 
    # current time (less 1 hour) is earlier than either 
    # asctime or desctime. Take testtimes[2] 
    # (they're sorted, after all ) and subtract 1 day from it.
    $testsecs = vap_perl::vaptime2systime($testtimes[2]);
    $time = vap_perl::systime2vaptime($testsecs);
  } else {
    $time=$lastrec;
  }
  
  
}

$satname =~ tr/a-z/A-Z/;
$fullregionname=join("",split( /_/, $region)) || "NOREGION";
$regionname=join( "", (split( /_/, $region))[3,4] ) || "NR";

print "\nArguments and variables are...\n";
print "\nsatname     = $satname\n";        
print "satnum      = $satnum\n" ;
print "sensornum   = $sensornum\n";      
print "lon         = @lonlim\n";         
print "lat         = @latlim\n" ;        
print "asctime     = $asctime\n";       
print "desctime    = $desctime\n";      
print "time        = $time\n" if $time; 
print "crdecimate  = @$crdecimate\n";  
print "length      = $length\n";  
print "delta       = $delta\n" if $delta; 
print "rainflag    = $rainflag\n";
print "rf_action   = $rf_action\n";
print "rf_color    = $rf_color\n";
print "excludecols = $excludecols\n\n";
print "Taking type = $type\n" if $type;  
print "Output overlay file will have region name $regionname\n";
print "Output HTTP file will have region name $fullregionname\n";

exit if ($tellme);

# Sanity check the arguments: 
@lonlim=vap_perl::fixlonrange( @lonlim );
do {
  vap_perl::VapMailErrorMsg( "cloud_overlay: $satname not in allowed list\n", 
			       "UNKNOWN SATNAME");
  die "$satname not in allowed list\n"; } unless $satname =~ /(GOES|GMS)/;
do {vap_perl::VapMailErrorMsg( "cloud_overaly: $satnum not in allowed list (8,10)\n", 
			"UNKNOWN SATNUM") &&
     die "$satnum not in allowed list (8,10)\n" } unless $satnum =~ /(5|8|10)/;
do {vap_perl::VapMailErrorMsg( "cloud_overaly: $sensornum not in allowed range (1-4)\n", 
			"UNKNOWN SENSORNUM") &&
     die "$sensornum not in allowed range (1-4)\n"}  unless $sensornum =~ /(1|2|3|4)/;
if (abs($lonlim[0]) > 360 || abs($lonlim[1]) > 360){ 
  vap_perl::VapMailErrorMsg("cloud_overlay: Out of range Long Lims\n  (@lonlim)\n", 
			     "LONGLIMS OUTOFRANGE");
  die "Out of range Long Lims\n  (@lonlim)\n";
}

if (abs($latlim[0]) > 90 || abs($latlim[1]) > 90) {
  vap_perl::VapMailErrorMsg("cloud_overlay: Out of range Lat Lims\n  (@latlim)\n", 
			     "LATLIMS OUTOFRANGE");
  die "Out of range Lat Lims\n  (@latlim)\n";
}




  #========================================
  #
  # Start the real processing
  #
  # ========================================


  # create lock file (for IDL session)

$user=$ENV{'USER'};
$overlay_dir=$vap_perl::VAP_OVERLAY;
$lock_file="$overlay_dir/$user.cloud_overlay.$$.lock";
open (LOCK,">$lock_file") || 
{ vap_perl::VapMailErrorMsg("cloud_overlay: Couldn't open $lock_file\n", 
			 "OPENERR <LOCKFILE>") && 
			     die "Couldn't open $lock_file\n"};
print LOCK "$$\n";
close (LOCK);

$minlon=$lonlim[0];
$maxlon=$lonlim[1];
$minlat=$latlim[0];
$maxlat=$latlim[1];
$mapLimits ="[ $minlon, $minlat, $maxlon, $maxlat ]";

if ($satname =~ /GMS/) {

 Gms5::GetAllFileLists() || 
     {vap_perl::VapMailErrorMsg(
	"cloud_overlay:Can't Get all Gms5 archives listings!\n",
			    "GMS5 GETALLFILELISTS") && 
	  die "Can't Get all Gms5 archives listings!\n"};
  @gms5sensornames=('ir1','ir2','ir3','vis');
  @isec=Gms5::GetIntersection($gms5sensornames[$sensornum-1]);
  if (!$isec[0]) { 
    vap_perl::VapMailErrorMsg("cloud_overlay: Can't get GMS5 intersect\n", 
			      "GMS5 INTERSECT");
      die "Can't get GMS5 intersection\n";
  } 
  $mindif=1.e10;
  $testsecs=vap_perl::vaptime2systime($time);
  foreach $datetime (@isec) {
    $syst=Gms5::Gms5DateTime2SysTime($datetime);
    $dif = abs($syst-$testsecs) ;
    if ( $dif <= $mindif ) {
      $gridded_file=$datetime ;
      $mindif = $dif;
    }
  }
  if ($mindif > 7200){ 
    $gridded_file="";
      # Don't fail if there isn't a file close enough!
      # But don't bother to FTP all the requisite files either!
      # Still send the error message, though!

     vap_perl::VapMailErrorMsg(
 	  "cloud_overlay: No Files closer than 2 hours! <$mindir>\n",
 			      "GMS5 MINDIFF");
#       die "No Files closer than 2 hours!<$mindif>\n";
  }  else {

    $T=time;
    Gms5::GetAll($gridded_file) || 
       do { vap_perl::VapMailErrorMsg(
             "cloud_overlay: Can't GetAll for datetime $gridded_file\n", 
	  	    "GMS5 GRIDDEDFILE") ;
          die "Can't GetAll for datetime $gridded_file\n"; }
    }
   $T=time-$T;
   print "GMS5::GetAll took $t seconds \n";

} else {

  # Supposedly we can now get and grid the AREA file 
  $T=time;
  $gridded_file = vap_perl::gag( $satnum, $sensornum, $time, 
				$minlon, $minlat, $maxlon, $maxlat );
  $T=time-$T;
  print "GAG took $T seconds\n";

    # New mode. Don't fail if the gridding didn't work. Just continue
    # and let it plot the vectors anyway.

#   if (!$gridded_file) {
#     vap_perl::VapMailErrorMsg(
# 	 "cloud_overlay: Unsuccessful call to vap_perl::gag, gridded_file=NULL\n",
# 			      "GOES BADGAG");
#       die "Unsuccessful call to vap_perl::gag, gridded_file=NULL\n";
#   }
      
  
}


# The IDL routines like time as yyyy/mm/dd/hh/mm. 
# So, construct this time string.
$idl_time_string=vap_perl::vaptime2idltime($time);
$idl_tmp_file="$overlay_dir/idl_called_by_perl_$$.pro";
print "Writing IDL tmp file $idl_tmp_file\n";
open(IDLFILE,">$idl_tmp_file") || 
    {vap_perl::VapMailErrorMsg(
	   "Cloud_overlay: Couldn't open $idl_tmp_file\n",
	      "BAD IDL TMPFILE OPEN") && 
		  die "Couldn't open $idl_tmp_file\n"};


$exe_str = "cloud_overlay,\'$gridded_file\',\'$idl_time_string\'";
$exe_str .= ",$delta,wpath = \'$vap_perl::VAP_WINDS\'";
$exe_str .= ",lockfile=\'$lock_file\',length=$length";
$exe_str .= ",CRDecimate=[".join(",",@$crdecimate)."]";
$exe_str .= ",ExcludeCols=\'$excludecols\'";
$exe_str .= ",rainflag=$rainflag,rf_action=$rf_action,rf_color=$rf_color";
$exe_str .= ",mapLimits=$mapLimits";
$exe_str .= ",/gridlines";
$exe_str .= ",gmsType=\'$gms5sensornames[$sensornum-1]\'" 
    if ($satname =~ /GMS/);
  
print IDLFILE "$exe_str\nexit\n" || 
   {vap_perl::VapMailErrorMsg(
       "cloud_overlay: Can't write to idl tmp file $idl_tmp_file\n",
       "BAD WRITE TO IDL TMPFILE") && 
	   die "Can't write to idl tmp file $idl_tmp_file\n"};
#  print IDLFILE "exit\n" || 
#      die "Can't write to idl tmp file $idl_tmp_file\n";
close IDLFILE;

print "wrote following to idl_tmp_file\n  $exe_str\n";

$exe_str=$vap_perl::IDLEXE." ".$idl_tmp_file;
$r=system( $exe_str )/256;

if ($r != 0){
  vap_perl::VapMailErrorMsg("cloud_overlay: Error in IDL\n",
			    "ERROR CALLING IDL");
    die " Error in IDL\n";
}

open ( LOCK, "<$lock_file") || 
  {vap_perl::VapMailErrorMsg(
	"cloud_overlay: Couldn't open $lock_file after IDL \n",
	      "ERROR OPEN LOCKFILE") && 
		  die "Couldn't open $lock_file after IDL \n"};
@idlout = <LOCK>;
close (LOCK);


  # see if there are any lines in the idl output file 
  # with the work ERROR in them. Exit if there are.
foreach $r (@idlout) {
  if ($r =~ /ERROR/) {
    print "Error in IDL processing \n";
    print @idlout;
    $msg=join "\n",@idlout;
    vap_perl::VapMailErrorMsg($msg,"ERRORINIDLPROC");
    exit;
  }
}

# unlink $idl_tmp_file || 
#     {vap_perl::VapMailErrorMsg(
# 	       "cloud_overlay: Couldn't unlink $idl_tmp_file\n",
# 	     "TMPFILE UNLINK ERROR") && 
# 	  die "Couldn't unlink $idl_tmp_file\n"};

unlink $lock_file  ||  print "Couldn't delete $lock_file \n";

  # goes_overlay gives the output gif file a name based on the input
  # grid file name get that name and rename the file to the standard
  # 'pac_overlay_$type.gif'

$output_file_name_file="$overlay_dir/auto_cloud_overlay_output_file.$$";

chdir $overlay_dir || 
    {vap_perl::VapMailErrorMsg(
	       "cloud_overlay: Couldn't CD to $overlay_dir\n",
	     "CD TO OVERLAY_DIR ERROR") && 
	  die " Couldn't CD to $overlay_dir\n\n"};

open (PICTURENAME,"<$output_file_name_file") || 
 {vap_perl::VapMailErrorMsg(
     "cloud_overlay: Can't open $output_file_name_file\n",
       "AUTO CLOUD OVERLAY OUTPUT FILE OPEN ERROR") && 
	   die "Can't open $output_file_name_file\n"};
@picturefile=<PICTURENAME>;
close(PICTURENAME);
  unlink "$output_file_name_file" || 
      print "Couldn't delete $output_file_name_file\n";

  # Read the picture name
$picture = "$picturefile[0]";
chop($picture);
@tmp = split("/",$picture);
$picture = $tmp[$#tmp];
@tmp = split( /\./, $picture );
$fileroot = $tmp[0];

  # Read the thumbnail name
$thumbnail = $picturefile[1];
chop($thumbnail);
@tmp = split("/",$thumbnail);
$thumbnail = $tmp[$#tmp];
@tmp = split( /\./, $thumbnail );
$thumbnailroot = $tmp[0];

   #
   #---------------------- the file ------------------------
   #
$file=$vap_perl::VAP_OVERLAY_ARCHIVE."/".$fileroot."-".$regionname.".jpeg";
print "Renaming $picture to $file\n";
copy($picture,$file) ||
  {vap_perl::VapMailErrorMsg(
	"cloud_overlay: Couldn't rename $picture to $file, error = $!\n",
	      "PICTURE COPY ERROR") && 
       die "Couldn't rename $picture to $file, error = $!\n"};
unlink $picture;
chmod 0755, $file || print  "Couldn't chmod $file to a+r\n";


  # create name of file in images archive to be linked to it.

$wwwfile=$vap_perl::VAP_WWW_TOP."/images/".$fullregionname.".jpeg";

  #delete it if it exists
if (-e $wwwfile) {
  unlink ($wwwfile ) || print "Couldn't unlink $wwwfile\n";
}



  # create the symbolic link to the gif file.
print "Linking $wwwfile to $file\n";
symlink( $file, $wwwfile ) || print "Couldn't link $wwwfile to $file \n";


   #
   #---------------------- And its thumbnail ------------------------
   #


  # copy thumbnail to image overlay archive.
$file=
  $vap_perl::VAP_OVERLAY_ARCHIVE."/".$thumbnailroot."-".$regionname.".TN.jpeg";
print "Renaming $thumbnail to $file\n";
copy($thumbnail,$file) ||
  {vap_perl::VapMailErrorMsg(
	    "cloud_overlay: Couldn't rename $thumbnail to $file, error = $!\n",
	     "THUMBNAIL COPY ERROR") && 
       die "Couldn't rename $thumbnail to $file, error = $!\n"};
unlink $thumbnail;
chmod 0755, $file || print  "Couldn't chmod $file to a+r\n";



  # Create the symbolic name for the thumbnail
$wwwfile=$vap_perl::VAP_WWW_TOP."/images/".$fullregionname.".TN.jpeg";
  #delete it if it exists
if (-e $wwwfile) {
  unlink ($wwwfile ) || print "Couldn't unlink $wwwfile\n";
}

  # create the symbolic link to the gif file.
print "Linking $wwwfile to $file\n";
symlink( $file, $wwwfile ) || print "Couldn't link $wwwfile to $file \n";

  # go to where the index.html is
chdir $vap_perl::VAP_WWW_TOP || 
   {vap_perl::VapMailErrorMsg("cloud_overlay: Couldn't go to $VAP_WWW_TOPDIR\n",
		      "CD ERROR WWW TOP DIR") && 
	die "Couldn't CD to $VAP_WWW_TOPDIR\n"};
print "11\n";

  # update the dates in that file
print "Updating index.html\n";
vap_perl::date_index();

  # make sure it's readible.
chmod 0644, "index.html" ||  
    {vap_perl::VapMailErrorMsg("cloud_overlay: Couldn't chmod index.html to 0644\n",
			       "INDEX.HTML CHMOD ERROR") && 
	 die "Couldn't chmod index.html to 0644\n"};
$tottime=time-$^T;

print "Total Time: $tottime\n";

exit;

